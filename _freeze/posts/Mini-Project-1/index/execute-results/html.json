{
  "hash": "837c2d9b7d32a5e2f4687133e15d6cd0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mini-Project-1\"\ndate: \"01-29-2005\"\nauthor: \"Clayton-Fogler\"\n---\n\n\n\n\n#### \"I have followed all rules for collaboration for this project, and I have not used generative AI on this project\" \\~ *Clayton Fogler*\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\n## create population graphs\n\nnorm_df <- tibble(x = seq(3, 17, length.out = 1000),\n                  dens = dnorm(x, mean = 10, sd = 2),\n                  pop = \"normal(10, 4)\")\nunif_df <- tibble(x = seq(7, 13, length.out = 1000),\n                  dens = dunif(x, 7, 13),\n                  pop = \"uniform(7, 13)\")\nexp_df <- tibble(x = seq(0, 10, length.out = 1000),\n                 dens = dexp(x, 0.5),\n                 pop = \"exp(0.5)\")\nbeta_df <- tibble(x = seq(0, 1, length.out = 1000),\n                  dens = dbeta(x, 8, 2),\n                  pop = \"beta(8, 2)\")\n\npop_plot <- bind_rows(norm_df, unif_df, exp_df, beta_df) |>\n  mutate(pop = fct_relevel(pop, c(\"normal(10, 4)\", \"uniform(7, 13)\",\n                                  \"exp(0.5)\", \"beta(8, 2)\")))\n\nggplot(data = pop_plot, aes(x = x, y = dens)) +\n  geom_line() +\n  theme_minimal() +\n  facet_wrap(~ pop, nrow = 1, scales = \"free\") +\n  labs(title = \"Population Distributions for Each Simulation Setting\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n\n\n## Normal Distribution, mu = 10, sigma\\^2\n\n#### Sample Minimum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\nmu <- 10 # population mean\nsigma <- 2 # population standard deviation\ngenerate_samp_min <- function(mu, sigma, n) {\nsingle_sample <- rnorm(n, mu, sigma)\nsample_min <- min(single_sample)\nreturn(sample_min)\n}\n## test function once:\ngenerate_samp_min(mu = mu, sigma = sigma, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.549541\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_min function\n## nsim times\nmins <- map_dbl(1:nsim, \\(i) generate_samp_min(mu = mu, sigma = sigma, n = n))\n## print some of the 5000 mins\n## each number represents the sample min from __one__ sample.\nmins_df <- tibble(mins)\nmins_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    mins\n   <dbl>\n 1  9.19\n 2  6.66\n 3  7.33\n 4  6.56\n 5  6.71\n 6  7.79\n 7  7.47\n 8  7.31\n 9  7.03\n10  9.51\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = mins_df, aes(x = mins)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Mins\",\ntitle = paste(\"Sampling Distribution of the \\nSample Min when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmins_df |>\nsummarise(min_samp_dist = mean(mins),\nvar_samp_dist = var(mins),\nsd_samp_dist = sd(mins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  min_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1          7.69          1.78         1.33\n```\n\n\n:::\n:::\n\n\n\n\n#### Sample Maximum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\nmu <- 10 # population mean\nsigma <- 2 # population standard deviation\ngenerate_samp_max <- function(mu, sigma, n) {\nsingle_sample <- rnorm(n, mu, sigma)\nsample_max <- max(single_sample)\nreturn(sample_max)\n}\n## test function once:\ngenerate_samp_max(mu = mu, sigma = sigma, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.84016\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_max function\n## nsim times\nmaxs <- map_dbl(1:nsim, \\(i) generate_samp_max(mu = mu, sigma = sigma, n = n))\n## print some of the 5000 maxs\n## each number represents the sample max from __one__ sample.\nmaxs_df <- tibble(maxs)\nmaxs_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    maxs\n   <dbl>\n 1  15.4\n 2  12.6\n 3  13.8\n 4  12.4\n 5  12.6\n 6  10.4\n 7  13.6\n 8  14.2\n 9  13.4\n10  12.6\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df, aes(x = maxs)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Maxs\",\ntitle = paste(\"Sampling Distribution of the \\nSample Max when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxs_df |>\nsummarise(max_samp_dist = mean(maxs),\nvar_samp_dist = var(maxs),\nsd_samp_dist = sd(maxs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  max_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1          12.3          1.74         1.32\n```\n\n\n:::\n:::\n\n\n\n\n## Uniform Distribution: theta1 = 7, theta2 = 13\n\n#### Sample Minimum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\ntheta1 <- 7\ntheta2 <- 13\nmu <- (theta1 + theta2)/2 # population mean\nsigma <- ((theta2 - theta1) ^ 2) / 12 # population standard deviation\ngenerate_samp_min <- function(theta1 = theta1, theta2 = theta2, n = n) {\nsingle_sample <- runif(n, theta1, theta2)\nsample_min <- min(single_sample)\nreturn(sample_min)\n}\n## test function once:\ngenerate_samp_min(theta1 = theta1, theta2 = theta2, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.863119\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_min function\n## nsim times\nmins <- map_dbl(1:nsim, \\(i) generate_samp_min(theta1 = theta1, theta2 = theta2, n = n))\n## print some of the 5000 mins\n## each number represents the sample min from __one__ sample.\nmins_df <- tibble(mins)\nmins_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    mins\n   <dbl>\n 1  7.24\n 2  7.51\n 3  7.06\n 4  8.10\n 5 11.0 \n 6  8.05\n 7  9.16\n 8  8.08\n 9  7.83\n10  7.11\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = mins_df, aes(x = mins)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Mins\",\ntitle = paste(\"Sampling Distribution of the \\nSample Min when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmins_df |>\nsummarise(min_samp_dist = mean(mins),\nvar_samp_dist = var(mins),\nsd_samp_dist = sd(mins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  min_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1          7.98         0.698        0.835\n```\n\n\n:::\n:::\n\n\n\n\n#### Sample Maximum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\ntheta1 <- 7\ntheta2 <- 13\nmu <- (theta1 + theta2)/2 # population mean\nsigma <- ((theta2 - theta1) ^ 2) / 12 # population standard deviation\ngenerate_samp_max <- function(theta1 = theta1, theta2 = theta2, n = n) {\nsingle_sample <- runif(n, theta1, theta2)\nsample_max <- max(single_sample)\nreturn(sample_max)\n}\n## test function once:\ngenerate_samp_max(theta1 = theta1, theta2 = theta2, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.7376\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_max function\n## nsim times\nmaxs <- map_dbl(1:nsim, \\(i) generate_samp_max(theta1 = theta1, theta2 = theta2, n = n))\n## print some of the 5000 mins\n## each number represents the sample max from __one__ sample.\nmaxs_df <- tibble(maxs)\nmaxs_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    maxs\n   <dbl>\n 1  13.0\n 2  12.0\n 3  12.7\n 4  10.0\n 5  12.1\n 6  11.3\n 7  12.6\n 8  12.5\n 9  12.5\n10  11.5\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df, aes(x = maxs)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Maxs\",\ntitle = paste(\"Sampling Distribution of the \\nSample Max when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxs_df |>\nsummarise(max_samp_dist = mean(maxs),\nvar_samp_dist = var(maxs),\nsd_samp_dist = sd(maxs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  max_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1          12.0         0.690        0.831\n```\n\n\n:::\n:::\n\n\n\n\n## Exponential Distribution, lambda = 0.5\n\n#### Sample Minimum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\nlambda <- 0.5\nmu <- 1 / lambda # population mean\nsigma <- sqrt(1/lambda ^ 2) # population standard deviation\ngenerate_samp_min <- function(lambda = lambda, n = n) {\nsingle_sample <- rexp(n, lambda)\nsample_min <- min(single_sample)\nreturn(sample_min)\n}\n## test function once:\ngenerate_samp_min(lambda = lambda, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.8510727\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_min function\n## nsim times\nmins <- map_dbl(1:nsim, \\(i) generate_samp_min(lambda = lambda, n = n))\n## print some of the 5000 mins\n## each number represents the sample min from __one__ sample.\nmins_df <- tibble(mins)\nmins_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n     mins\n    <dbl>\n 1 0.512 \n 2 0.0375\n 3 0.123 \n 4 0.0912\n 5 0.108 \n 6 0.0504\n 7 0.127 \n 8 0.153 \n 9 0.102 \n10 0.504 \n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = mins_df, aes(x = mins)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Mins\",\ntitle = paste(\"Sampling Distribution of the \\nSample Min when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmins_df |>\nsummarise(min_samp_dist = mean(mins),\nvar_samp_dist = var(mins),\nsd_samp_dist = sd(mins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  min_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1         0.409         0.167        0.408\n```\n\n\n:::\n:::\n\n\n\n\n#### Sample Maximum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\nlambda <- 0.5\nmu <- 1 / lambda # population mean\nsigma <- sqrt(1/lambda ^ 2) # population standard deviation\ngenerate_samp_max <- function(lambda = lambda, n = n) {\nsingle_sample <- rexp(n, lambda)\nsample_max <- max(single_sample)\nreturn(sample_max)\n}\n## test function once:\ngenerate_samp_max(lambda = lambda, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.51232\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_max function\n## nsim times\nmaxs <- map_dbl(1:nsim, \\(i) generate_samp_max(lambda = lambda, n = n))\n## print some of the 5000 maxs\n## each number represents the sample max from __one__ sample.\nmaxs_df <- tibble(maxs)\nmaxs_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    maxs\n   <dbl>\n 1  4.23\n 2  8.00\n 3  4.11\n 4  2.37\n 5  4.05\n 6  5.90\n 7  5.28\n 8  5.89\n 9  2.44\n10  8.22\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df, aes(x = maxs)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Maxs\",\ntitle = paste(\"Sampling Distribution of the \\nSample Max when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxs_df |>\nsummarise(max_samp_dist = mean(maxs),\nvar_samp_dist = var(maxs),\nsd_samp_dist = sd(maxs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  max_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1          4.60          5.80         2.41\n```\n\n\n:::\n:::\n\n\n\n\n## Beta Distribution, alpha = 8, beta = 2\n\n#### Sample Minimum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\nalpha <- 8\nbeta <- 2\nmu <- alpha / (alpha + beta) # population mean\nsigma <- (alpha * beta) / ((alpha + beta) ^ 2 * (alpha + beta + 1)) # population standard deviation\ngenerate_samp_min <- function(alpha, beta, n) {\nsingle_sample <- rbeta(n, alpha, beta)\nsample_min <- min(single_sample)\nreturn(sample_min)\n}\n## test function once:\ngenerate_samp_min(alpha = alpha, beta = beta, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.6856087\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_min function\n## nsim times\nmins <- map_dbl(1:nsim, \\(i) generate_samp_min(alpha = alpha, beta = beta, n = n))\n## print some of the 5000 mins\n## each number represents the sample min from __one__ sample.\nmins_df <- tibble(mins)\nmins_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    mins\n   <dbl>\n 1 0.712\n 2 0.517\n 3 0.587\n 4 0.734\n 5 0.731\n 6 0.613\n 7 0.640\n 8 0.598\n 9 0.709\n10 0.771\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = mins_df, aes(x = mins)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Mins\",\ntitle = paste(\"Sampling Distribution of the \\nSample Min when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmins_df |>\nsummarise(min_samp_dist = mean(mins),\nvar_samp_dist = var(mins),\nsd_samp_dist = sd(mins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  min_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1         0.646        0.0112        0.106\n```\n\n\n:::\n:::\n\n\n\n\n#### Sample Maximum\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5 # sample size\nalpha <- 8\nbeta <- 2\nmu <- alpha / (alpha + beta) # population mean\nsigma <- (alpha * beta) / ((alpha + beta) ^ 2 * (alpha + beta + 1)) # population standard deviation\ngenerate_samp_max <- function(alpha, beta, n) {\nsingle_sample <- rbeta(n, alpha, beta)\nsample_max <- max(single_sample)\nreturn(sample_max)\n}\n## test function once:\ngenerate_samp_max(alpha = alpha, beta = beta, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9632449\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000 # number of simulations\n## code to map through the function.\n## the \\(i) syntax says to just repeat the generate_samp_max function\n## nsim times\nmaxs <- map_dbl(1:nsim, \\(i) generate_samp_max(alpha = alpha, beta = beta, n = n))\n## print some of the 5000 maxs\n## each number represents the sample max from __one__ sample.\nmaxs_df <- tibble(maxs)\nmaxs_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    maxs\n   <dbl>\n 1 0.959\n 2 0.914\n 3 0.864\n 4 0.983\n 5 0.933\n 6 0.939\n 7 0.972\n 8 0.921\n 9 0.917\n10 0.880\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df, aes(x = maxs)) +\ngeom_histogram(colour = \"deeppink4\", fill = \"deeppink1\", bins = 20) +\ntheme_minimal() +\nlabs(x = \"Observed Sample Maxs\",\ntitle = paste(\"Sampling Distribution of the \\nSample Max when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmaxs_df |>\nsummarise(max_samp_dist = mean(maxs),\nvar_samp_dist = var(maxs),\nsd_samp_dist = sd(maxs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  max_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1         0.923       0.00207       0.0455\n```\n\n\n:::\n:::\n\n\n\n\n|   | $\\text{N}(\\mu = 10, \\sigma^2 = 4)$ | $\\text{Unif}(\\theta_1 = 7, \\theta_2 = 13)$ | $\\text{Exp}(\\lambda = 0.5)$ | $\\text{Beta}(\\alpha = 8, \\beta = 2)$ |\n|:------------:|:------------:|:------------:|:------------:|:------------:|\n| $\\text{E}(Y_{min})$ | 7.66 | 8.01 | 0.40 | 0.65 |\n| $\\text{E}(Y_{max})$ | 12.32 | 12.01 | 4.56 | 0.92 |\n|  |  |  |  |  |\n| $\\text{SE}(Y_{min})$ | 1.36 | 0.84 | 0.40 | 0.11 |\n| $\\text{SE}(Y_{max})$ | 1.34 | 0.85 | 2.41 | 0.46 |\n\n## Follow Up Questions\n\n#### Question 1: Briefly summarise how SE(Ymin) and SE(Ymax) compare for each of the above population models. Can you propose a general rule or result for how SE(Ymin) and SE(Ymax) compare for a given population?\n\n-   For both Normal and uniform distributions, the SE for both Ymin and Ymax are very similar. This is no suprise because both of the distributions are \"even\", meaning if you draw a line down the middle, they would be identical on both sides. Because of this, you would expect the SE to be the same on both ends. A general rule for these two would be you only need to find the SE for one of the two, and then once you find it you know the SE for both.\n\n-   Now, for Exponential and Beta distributions, the SE(Ymin) was different than the SE(Ymax). Why is this the case? Well, for exponential, the SE(Ymin) was small because when you look at the graph, it is not spread out. On the other hand, SE(Ymax) is much bigger. This makes sense because on the max side, y is approaching 0, which gives the max a wide range. This is a similar case for the beta distribution, however, the SE(Ymax) is small while the SE(Ymin) is large. The only general rule I could think of is the end that approaches 0 will have a larger SE than the end that does not approach 0.\n\n#### Question 2: Choose either the third (Exponetial) or fourth (beta) population model from the table above. For that population model, find the pdf of Ymin and Ymax, and, for each of those random variables, sketch the pdfs and use integration to calculate the expected value and standard error. What do you notice about how your answers compare to the simulated answers? Some code it given below to help you plot the pdfs in R:\n\n-   Using the exponential population model, To find the pdf for Ymin and Ymax, we start with finding the cdf. We can do this by finding the integral from o to x of 0.5e \\^ (-0.5y) dy which is equal to 1 - e \\^ (-0.5y). With this, we can now find:\n\n    -   fmin(y) = 5(1 - (1 - e \\^ (-0.5x))) \\^ 4 \\* 0.5e \\^ (-0.5x)\n    -   fmax(y) = 5(1 - e \\^ (-0.5x)) \\^ 4 \\* 0.5e \\^ (-0.5x)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\n## CHANGE 0 and 3 to represent where you want your graph to start and end\n## on the x-axis\nx <- seq(0, 3, length.out = 1000)\n## CHANGE to be the pdf you calculated. Note that, as of now, \n## this is not a proper density (it does not integrate to 1).\ndensity <- n * (1 - (1 - exp(1) ^ (-0.5 * x))) ^ n - 1 * 0.5 * exp(1) ^ (-0.5 * x)\n\n\n## put into tibble and plot\nsamp_min_df <- tibble(x, density)\nggplot(data = samp_min_df, aes(x = x, y = density)) +\n  geom_line() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\n## CHANGE 0 and 3 to represent where you want your graph to start and end\n## on the x-axis\nx <- seq(4, 7, length.out = 1000)\n## CHANGE to be the pdf you calculated. Note that, as of now, \n## this is not a proper density (it does not integrate to 1).\ndensity <-  n * (1 - exp(1) ^ (-0.5 * x))  ^ n - 1 * 0.5 * exp(1) ^ (-0.5 * x)\n\n\n## put into tibble and plot\nsamp_min_df <- tibble(x, density)\nggplot(data = samp_min_df, aes(x = x, y = density)) +\n  geom_line() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n-   Theoretical: E(Ymin) and SE(Ymin)\n    -   To find the E(Ymin), we calculate the integral from 0 to infinity of x \\* 5(1 - (1 - e \\^ (-0.5x))) \\^ 4 \\* 0.5e \\^ (-0.5x). We get 0.4. This is very very close to our simulated E(Ymin). For SE(Ymin), we must calculate the Var(Ymin). We calculate the integral from 0 to infinity of x\\^2 \\* 5(1 - (1 - e \\^ (-0.5y))) \\^ 4 \\* 0.5e \\^ (-0.5y). We get 0.32. We then use this to do 0.32 - (0.4)\\^2 = 0.16. When we take the square root of 0.16, we get the SE(Ymin) = 0.4. This is very similar to our simulated SE(Ymin).\n-   Theoretical: E(Ymax) and SE(Ymax)\n    -   To find the E(Ymax), we calculate the integral from 0 to infinity of x \\* 5(1 - e \\^ (-0.5x)) \\^ 4 \\* 0.5e \\^ (-0.5x). We get 4.5666. This is very very close to our simulated E(Ymax). For SE(Ymax), we must calculate the Var(Ymax). We calculate the integral from 0 to infinity of x\\^2 \\* 5(1 - e \\^ (-0.5x)) \\^ 4 \\* 0.5e \\^ (-0.5x). We get 26.7088. We then use this to do 26.7088 - (4.5666)\\^2 = 5.855. When we take the square root of 5.855, we get the SE(Ymax) = 2.4197. This is very similar to our simulated SE(Ymax).",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}